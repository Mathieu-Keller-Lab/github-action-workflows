name: Semantic Release

on:
  workflow_call:
    inputs:
      dry:
        description: A boolean parameter that controls whether the action runs in dry-run mode. When set to `true`, no actual releases are created, and the action simulates the release process.
        type: boolean
        default: false
      release-branch:
        description: The branch where releases are created. This parameter allows you to specify the branch for creating releases. The default is set to `main`.
        type: string
        default: main
    outputs:
      new_version:
        description: This output contains the new version. If the release is not on the specified release branch, the version will be the branch name plus the commit hash.
        value: ${{ jobs.release.outputs.new_version }}
      has_new_version:
        description: This output says if a real new version exists (if only chores are in the new version than it will have no new version number)
        value: ${{ jobs.release.outputs.has_new_version }}
permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    name: release
    runs-on: self-hosted
    outputs:
      new_version: ${{ steps.save-version.outputs.new_version }}
      has_new_version: ${{ steps.release.outputs.has_new_version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        if: ${{ github.event_name == 'pull_request' }}
        with:
          fetch-depth: 0
          ref: ${{ github.head_ref }}
      - name: Checkout
        uses: actions/checkout@v5
        if: ${{ github.event_name != 'pull_request' }}
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v6
        with:
          node-version: 24
      - name: setup plugins
        run: |
          npm install -g semantic-release@25.0.0
          if [[ -f package.json ]]; then
            mv package.json package.json.tmp
          fi
          npm install --no-save @semantic-release/commit-analyzer@13.0.1 @semantic-release/release-notes-generator@14.1.0 @semantic-release/exec@7.1.0 @semantic-release/git@10.0.1 @semantic-release/github@12.0.1
          if [[ -f package.json.tmp ]]; then
             mv package.json.tmp package.json
          fi
      - name: setup config
        run: |
          cat > .releaserc.yaml << EOF
          tagFormat: "\${version}"
          plugins:
            - "@semantic-release/commit-analyzer"
            - - "@semantic-release/release-notes-generator"
              - output: release_notes.txt
            - - "@semantic-release/exec"
              - verifyReleaseCmd: "echo \"\${nextRelease.version}\" > VERSION.txt;"
            - "@semantic-release/git"
            - "@semantic-release/github"
          EOF
      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Trick semantic-release into thinking we're not in a CI environment
          unset GITHUB_ACTIONS
          if [[ ${{ inputs.dry }} == 'true' ]]; then
            npx semantic-release --dry-run --no-ci --branches ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}},${{ inputs.release-branch }} > release_notes.txt 2>&1
          else 
            npx semantic-release --branches ${{ inputs.release-branch }}
          fi
      - name: read release files
        id: release
        run: |
          if [[ -f VERSION.txt ]]; then
            echo "release_version=$(cat VERSION.txt)" >> $GITHUB_OUTPUT
            echo "has_new_version=true" >> $GITHUB_OUTPUT
          else
            echo 'has_new_version=false' >> $GITHUB_OUTPUT
          fi
      - name: save-version-in-output
        id: save-version
        run: |
          if [[ ${{ github.ref }} == "refs/heads/${{ inputs.release-branch }}" && ${{ steps.release.outputs.has_new_version }} == 'true' ]]; then
            echo "new_version=${{ steps.release.outputs.release_version }}" >> "$GITHUB_OUTPUT"
          else
            echo "new_version=$(echo ${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}} | sed -r 's/\//_/g')_$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"
          fi
      - name: write release notes preview
        uses: actions/github-script@v8
        if: ${{ github.event_name == 'pull_request' && inputs.dry == true}}
        env:
          RELEASE_VERSION: ${{ steps.release.outputs.release_version }}
          HAS_NEW_VERSION: ${{ steps.release.outputs.has_new_version }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const releaseNotesRaw = fs.existsSync('release_notes.txt') ? fs.readFileSync('release_notes.txt', 'utf8') : '';
            const hasNewVersion = process.env.HAS_NEW_VERSION === 'true';
            const releaseVersion = process.env.RELEASE_VERSION;

            // Parse release notes from output (extract after "Release note for version")
            const lines = releaseNotesRaw.split('\n');
            let start = false;
            let notes = [];
            for (const line of lines) {
              if (line.includes('Release note for version')) {
                start = true;
                continue;
              }
              if (start) {
                notes.push(line);
              }
            }
            const releaseNotesText = notes.join('\n').trim();

            // Set body to only the release notes (or a fallback message)
            let body = releaseNotesText || 'No release notes available.';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
        
            const botComment = comments.find(comment => comment.user.type === 'Bot' && comment.body.includes('# Release Info'));  // Update this search if needed
            body = "# Release Info\n" + body; 
            if (botComment) {
              github.rest.issues.updateComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body
              });
            }
